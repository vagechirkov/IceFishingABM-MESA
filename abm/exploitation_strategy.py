import numpy as np
from scipy.special import expit  # logistic sigmoid


class ExploitationStrategy:
    def __init__(self, threshold, **kwargs):
        # TODO: implement parameters
        self.threshold = threshold

    def stay_on_patch(self, time_on_patch, time_since_last_catch):
        if (time_on_patch > self.threshold) and (
            time_since_last_catch > self.threshold
        ):
            return False
        return True


class IceFishingExploitationStrategy:
    def __init__(
        self,
        time_weight=0.8,
        social_feature_weight=-0.33,
        baseline_weight=-3,
        fish_catch_weight=-1.7,
        step_minutes=1.0,
        base_step_minutes=1 / 6,
        rng=None,
    ):
        self.baseline_weight = baseline_weight  # baseline weight
        self.fish_catch_weight = fish_catch_weight  # is this spot successful ?
        self.time_weight = time_weight
        self.social_feature_weight = social_feature_weight

        self.rng = rng if rng is not None else np.random.default_rng()
        self.step_minutes = step_minutes
        self.base_step_minutes = base_step_minutes  # original time unit was 10s

        self.p_leave = expit(self.baseline_weight)

    def stay_on_patch(self, time_since_last_catch, is_spot_successful: float = 0, z_social_feature: float = 0):
        """Return True if agent stays, False if agent leaves."""
        # logistic function: logit^-1(w * f)
        self.p_leave = expit(
            self.baseline_weight
            + self.fish_catch_weight * is_spot_successful
            + self.time_weight * time_since_last_catch
            + self.social_feature_weight * z_social_feature
        )

        if not np.allclose(self.step_minutes, self.base_step_minutes, rtol=0.1):
            self.p_leave = np.clip(self.p_leave, 0.0, 1.0 - 1e-12)  # numeric safety
            # Convert the per-base-interval probability p_base (fit at Δ0) to a constant
            # hazard λ on that interval: p_base = 1 - exp(-λ Δ0) ⇒ λ = -ln(1 - p_base)/Δ0.
            # Then compute the leave probability for the current step Δ via
            # p_step = 1 - exp(-λ Δ). This is exactly equivalent to compounding:
            # p_step = 1 - (1 - p_base)^(Δ/Δ0), making the rule time-step invariant.
            lam = -np.log1p(-self.p_leave) / self.base_step_minutes
            self.p_leave = 1.0 - np.exp(-lam * self.step_minutes)

        return self.rng.random() >= self.p_leave  # True = stay, False = leave

    def reset_p_leave(self):
        self.p_leave = expit(self.baseline_weight)


def simulate_p_and_decisions(strategy: IceFishingExploitationStrategy, times, catch_times, z_social_feature):
    """Return p_leave(t) and leave(t) for one run."""
    p_series = np.zeros_like(times, dtype=float)
    leave_series = np.zeros_like(times, dtype=int)

    last_catch = 0.0
    cidx = 0
    for i, t in enumerate(times):
        while cidx < len(catch_times) and t >= catch_times[cidx]:
            last_catch = catch_times[cidx]
            cidx += 1
        time_since_last = t - last_catch

        stayed = strategy.stay_on_patch(
            time_since_last_catch=time_since_last,
            is_spot_successful=float(cidx > 0),
            z_social_feature=z_social_feature)  # updates p_leave
        p_series[i] = strategy.p_leave
        leave_series[i] = 0 if stayed else 1

    return p_series, leave_series


if __name__ == "__main__":
    import matplotlib.pyplot as plt
    import seaborn as sns
    import pandas as pd
    # catch_times = [1.5, 3.2, 5.0, 8.2, 11.5, 14.0]
    catch_times = [2.0, 3.0, 5.0, 8.0, 11.0, 14.0]
    z_social_feature=0
    total_minutes = 17.0

    for dt in [1 / 6]:  # 0.17, 0.33, 0.5, 1.0
        times = np.arange(0.0, total_minutes + dt, dt)
        n_realizations = 200

        master_rng = np.random.default_rng(42)

        # Simulate multiple realizations
        p_trajs = []
        leave_trajs = []
        for r in range(n_realizations):
            start = IceFishingExploitationStrategy(
                baseline_weight=-3,
                fish_catch_weight=-1.7,
                time_weight=0.8,  # 0.13 * 6  # time in minutes, not in 10s intervals
                social_feature_weight=-0.33,
                step_minutes=dt,
            )
            p_series, leave_series = simulate_p_and_decisions(start, times, catch_times, z_social_feature)
            p_trajs.append(p_series)
            leave_trajs.append(leave_series)

        p_trajs = np.vstack(p_trajs)          # shape (R, T)
        leave_trajs = np.vstack(leave_trajs)  # shape (R, T)

        df = pd.DataFrame({
            "time": np.tile(times, n_realizations),
            "leave": leave_trajs.ravel()
        })
        df_stay = df.copy()
        df_stay["leave"] = 1 - df_stay["leave"]
        df["kind"] = "Empirical leave"
        df_stay["kind"] = "Empirical stay"
        df_long = pd.concat([df.rename(columns={"leave": "value"}),
                             df_stay.rename(columns={"leave": "value"})],
                            ignore_index=True)

        mean_p = p_trajs.mean(axis=0)

        # Plot
        sns.set(style="whitegrid")
        fig, ax = plt.subplots(figsize=(9, 4.5))

        # Empirical ribbons via seaborn (mean with 90% CI)
        # sns.lineplot(
        #     data=df_long,
        #     x="time", y="value", hue="kind", hue_order=["Empirical leave"],
        #     estimator="mean", errorbar=("ci", 90),
        #     ax=ax
        # )

        ax.plot(times, mean_p, linewidth=2.0, label="Model $p_{\\text{leave}}$ (mean)")

        # Catch markers
        for ct in catch_times:
            ax.axvline(ct, linestyle="--", alpha=0.5, color="black")

        ax.set_xlabel("Time (minutes)")
        ax.set_ylabel("Probability")
        ax.set_xlim(0, total_minutes)
        ax.set_ylim(0, 0.15)

        handles, labels = ax.get_legend_handles_labels()
        uniq = dict(zip(labels, handles))
        ax.legend(uniq.values(), uniq.keys(), loc="upper left")

        plt.tight_layout()
        plt.show()