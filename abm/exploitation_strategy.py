import numpy as np
from scipy.special import expit  # logistic sigmoid


class ExploitationStrategy:
    def __init__(self, threshold, **kwargs):
        # TODO: implement parameters
        self.threshold = threshold

    def stay_on_patch(self, time_on_patch, time_since_last_catch):
        if (time_on_patch > self.threshold) and (
            time_since_last_catch > self.threshold
        ):
            return False
        return True


class IceFishingExploitationStrategy:
    def __init__(self, time_weight=0.8, baseline_weight=-5, rng=None):
        self.time_weight = time_weight
        self.baseline_weight = baseline_weight  # baseline weight + first discovery bonus
        self.rng = rng if rng is not None else np.random.default_rng()
        self.p_leave = 0

    def stay_on_patch(self, time_since_last_catch):
        """Return True if agent stays, False if agent leaves."""
        if time_since_last_catch == 0:
            self.p_leave = 0
        else:
            # logistic function: logit^-1(w * f)
            self.p_leave = expit(self.time_weight * time_since_last_catch + self.baseline_weight)

        return self.rng.random() >= self.p_leave  # True = stay, False = leave


def simulate_p_and_decisions(strategy, times, catch_times):
    """Return p_leave(t) and leave(t) for one run."""
    p_series = np.zeros_like(times, dtype=float)
    leave_series = np.zeros_like(times, dtype=int)

    last_catch = 0.0
    cidx = 0
    for i, t in enumerate(times):
        while cidx < len(catch_times) and t >= catch_times[cidx]:
            last_catch = catch_times[cidx]
            cidx += 1
        time_since_last = t - last_catch

        stayed = strategy.stay_on_patch(time_since_last)  # updates p_leave
        p_series[i] = strategy.p_leave
        leave_series[i] = 0 if stayed else 1

    return p_series, leave_series


if __name__ == "__main__":
    import matplotlib.pyplot as plt
    import seaborn as sns
    import pandas as pd

    # Setup
    catch_times = [1.5, 3.2, 5.0, 8.2, 11.5, 14.0]
    total_minutes = 17.0
    dt = 0.17  # ~10 seconds
    times = np.arange(0.0, total_minutes + dt, dt)

    n_realizations = 200
    time_weight = 0.13 * 6
    baseline_weight = -5
    master_rng = np.random.default_rng(42)

    # Simulate multiple realizations
    p_trajs = []
    leave_trajs = []
    for r in range(n_realizations):
        start = IceFishingExploitationStrategy(
            time_weight=time_weight,
            baseline_weight=-5,
        )
        p_series, leave_series = simulate_p_and_decisions(start, times, catch_times)
        p_trajs.append(p_series)
        leave_trajs.append(leave_series)

    p_trajs = np.vstack(p_trajs)          # shape (R, T)
    leave_trajs = np.vstack(leave_trajs)  # shape (R, T)

    df = pd.DataFrame({
        "time": np.tile(times, n_realizations),
        "leave": leave_trajs.ravel()
    })
    df_stay = df.copy()
    df_stay["leave"] = 1 - df_stay["leave"]
    df["kind"] = "Empirical leave"
    df_stay["kind"] = "Empirical stay"
    df_long = pd.concat([df.rename(columns={"leave": "value"}),
                         df_stay.rename(columns={"leave": "value"})],
                        ignore_index=True)

    mean_p = p_trajs.mean(axis=0)

    # Plot
    sns.set(style="whitegrid")
    fig, ax = plt.subplots(figsize=(9, 4.5))

    # Empirical ribbons via seaborn (mean with 90% CI)
    # sns.lineplot(
    #     data=df_long,
    #     x="time", y="value", hue="kind", hue_order=["Empirical leave"],
    #     estimator="mean", errorbar=("ci", 90),
    #     ax=ax
    # )

    ax.plot(times, mean_p, linewidth=2.0, label="Model $p_{\\text{leave}}$ (mean)")

    # Catch markers
    for ct in catch_times:
        ax.axvline(ct, linestyle="--", alpha=0.5, color="black")

    ax.set_xlabel("Time (minutes)")
    ax.set_ylabel("Probability")
    ax.set_title("Empirical leave/stay with 90% CI vs. model $p_{\\text{leave}}$")
    ax.set_xlim(0, total_minutes)
    ax.set_ylim(0, 0.15)

    handles, labels = ax.get_legend_handles_labels()
    uniq = dict(zip(labels, handles))
    ax.legend(uniq.values(), uniq.keys(), loc="upper left")

    plt.tight_layout()
    plt.show()